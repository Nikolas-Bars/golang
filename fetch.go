package main

import (
	"fmt"      // пакет для форматированного вывода
	"io"       // пакет для работы с потоками ввода/вывода
	"net/http" // пакет для выполнения HTTP-запросов
	"os"       // пакет для работы с аргументами, stderr и выходом
	"strings"
)

func main() {
	// Перебираем все аргументы командной строки, начиная с первого после имени исполняемого файла
	for _, url := range os.Args[1:] {

		// Если URL не начинается с "http://" или "https://", добавляем "http://"
		// Это позволяет пользователю вводить просто "example.com", и программа всё равно будет работать
		if !strings.HasPrefix(url, "http://") && !strings.HasPrefix(url, "https://") {
			url = "http://" + url
		}

		// Отправляем HTTP GET-запрос по указанному URL
		resp, err := http.Get(url)

		// Если произошла ошибка при отправке запроса, выводим сообщение об ошибке в stderr
		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch: %v \n", err)
			os.Exit(1) // Завершаем программу с кодом 1 (ошибка)
		}

		// Откладываем закрытие тела ответа — важно, чтобы не было утечки соединений
		// defer откладывает выполнение resp.Body.Close до момента выхода из текущей функции
		defer resp.Body.Close()

		// Копируем тело ответа (resp.Body) напрямую в стандартный вывод (os.Stdout)
		// Это позволяет выводить ответ сразу, без хранения его целиком в памяти
		_, err = io.Copy(os.Stdout, resp.Body)

		// Если при чтении тела возникла ошибка — сообщаем и выходим
		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch: reading %s: %v \n", url, err)
			os.Exit(1)
		}
	}
}
